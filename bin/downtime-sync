#!/usr/bin/python

# Copyright (c) 2013 GRNET S.A., SRCE, IN2P3 CNRS Computing Centre
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the
# License. You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an "AS
# IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
# express or implied. See the License for the specific language
# governing permissions and limitations under the License.
#
# The views and conclusions contained in the software and
# documentation are those of the authors and should not be
# interpreted as representing official policies, either expressed
# or implied, of either GRNET S.A., SRCE or IN2P3 CNRS Computing
# Centre
#
# The work represented by this source file is partially funded by
# the EGI-InSPIRE project through the European Commission's 7th
# Framework Programme (contract # INFSO-RI-261323)

import urllib
import os
import datetime
import xml.dom.minidom
import httplib
import sys
import pprint

import avro.schema
from avro.datafile import DataFileWriter
from avro.io import DatumWriter

defaultConfig = '/etc/ar-sync/downtime-sync.conf'

LegMapServType = {'SRM' : 'SRMv2'}
defaultArgDateFormat = '%Y-%m-%d'

readers = ['gocdb']
writers = ['file', 'avro']

###################################################
#
# configuration loader
#
###################################################
def loadConfiguration(confile):
     #load config
     configFile = None
     configFields = dict()
     if os.path.isfile(confile):
         configFile = open(confile, 'r')
         lines = configFile.readlines()

         for line in lines:
             if line[0] == '#':
                 continue
             splitLine = line.split('=')
             if len(splitLine) > 1:
                 key = splitLine[0].strip()
                 value = splitLine[1].strip()
                 value = value.decode('string_escape')
                 if value[0] == "'":
                     if value [-1] == "'":
                         value = value[1:-1]
                     else:
                         continue
                 elif value[0] == '"':
                     if value [-1] == '"':
                         value = value[1:-1]
                     else:
                         continue
                 else:
                     value = int(value)
                 configFields[key] = value

         configFile.close()

     return configFields

###################################################
#
# create output file name
#
###################################################
def createOutputFilename(directory, fileTemplate, timestamp):
    return directory + '/' + (fileTemplate % timestamp)

###################################################
#
# Readers
#
###################################################
class DowntimeReader(object):

    def loadConfiguration(configFields):
        """Loading config"""

    def getDowntimes(start, end):
        """Getting downtimes"""

class GOCDBReader(DowntimeReader):

    def __init__(self):
        self.gocdbHost = 'goc.egi.eu'
        self.gocdbUrl = 'https://'+self.gocdbHost+'/gocdbpi/'
        self.hostKey = '/etc/grid-security/hostkey.pem'
        self.hostCert = '/etc/grid-security/hostcert.pem'
        self.outputDir = '/var/lib/ar-sync'
        self.argDateFormat = "%Y-%m-%d"
        self.WSDateFormat = "%Y-%m-%d %H:%M"

    def loadConfiguration(self, configFields):
        if 'gocdbHost' in configFields:
             self.gocdbHost = configFields['gocdbHost']
        if 'gocdbUrl' in configFields:
             self.gocdbUrl = configFields['gocdbUrl']
        if 'hostKey' in configFields:
             self.hostKey = configFields['hostKey']
        if 'hostCert' in configFields:
             self.hostCert = configFields['hostCert']
        if 'argDateFormat' in configFields:
             self.argDateFormat = configFields['argDateFormat']
        if 'WSDateFormat' in configFields:
             self.WSDateFormat = configFields['WSDateFormat']

    def getDowntimes(self, start, end):
        filteredDowntimes = list()

        conn = httplib.HTTPSConnection(self.gocdbHost, 443, self.hostKey, self.hostCert)
        conn.request('GET', '/gocdbpi/private/' + '?method=get_downtime&windowstart=%s&windowend=%s' % (start.strftime(self.argDateFormat), end.strftime(self.argDateFormat)))
        res = conn.getresponse()
        if res.status == 200:
            doc = xml.dom.minidom.parseString(res.read())
            downtimes = doc.getElementsByTagName('DOWNTIME')

            for downtime in downtimes:
                classification = downtime.getAttributeNode('CLASSIFICATION').nodeValue
                hostname = downtime.getElementsByTagName('HOSTNAME')[0].childNodes[0].data
                serviceType = downtime.getElementsByTagName('SERVICE_TYPE')[0].childNodes[0].data
                startStr = downtime.getElementsByTagName('FORMATED_START_DATE')[0].childNodes[0].data
                endStr = downtime.getElementsByTagName('FORMATED_END_DATE')[0].childNodes[0].data
                severity = downtime.getElementsByTagName('SEVERITY')[0].childNodes[0].data

                startTime = datetime.datetime.strptime(startStr, self.WSDateFormat)
                endTime = datetime.datetime.strptime(endStr, self.WSDateFormat)

                if (startTime < start):
                    startTime = start
                if (endTime > end):
                    endTime = end

                if classification == 'SCHEDULED' and severity == 'OUTAGE':
                    dt = dict()
                    dt['hostname'] = hostname
                    dt['service'] = serviceType
                    dt['start_time'] = startTime.strftime('%Y-%m-%d %H:%M').replace(' ', 'T', 1).replace(' ', ':') + ':00Z'
                    dt['end_time'] = endTime.strftime('%Y-%m-%d %H:%M').replace(' ', 'T', 1).replace(' ', ':') + ':00Z'
                    filteredDowntimes.append(dt)
        else:
            print('ERROR: Connection to GOCDB failed: ' + res.reason)

        return filteredDowntimes

###################################################
#
# Writers
#
###################################################
class DowntimeWriter(object):

    def loadConfiguration(configFields):
        """Loading config"""

    def writeDowntimes(downtimes, date):
        """Getting downtimes"""

class FileWritter(DowntimeWriter):

    def __init__(self):
        self.outputDir = '/var/lib/ar-sync'
        self.outputFileTemplate = 'downtimes_%s.out'
        self.outputFileFormat = '%s\001%s\001%s\001%s\r\n'

    def loadConfiguration(self, configFields):
        if 'outputDir' in configFields:
             self.outputDir = configFields['outputDir']
        if 'outputFileTemplate' in configFields:
             self.outputFileTemplate = configFields['outputFileTemplate']
        if 'outputFileFormat' in configFields:
             self.outputFileFormat = configFields['outputFileFormat']

    def writeDowntimes(self, downtimes, date):
        filename = createOutputFilename(self.outputDir, self.outputFileTemplate, date)
        outFile = open(filename, 'w')
        for dt in downtimes:
            outFile.write(self.outputFileFormat % ( dt['hostname'],
                       dt['service'],
                       dt['start_time'],
                       dt['end_time'], ))
            if dt['service'] in LegMapServType.keys():
                outFile.write(self.outputFileFormat % (dt['hostname'],
                        LegMapServType[dt['service']],
                        dt['start_time'],
                        dt['end_time'], ))
        outFile.close();

class AvroWritter(DowntimeWriter):

    def __init__(self):
        self.avroOutputDir = '/var/lib/ar-sync'
        self.avroOutputFileTemplate = 'downtimes_%s.avro'
        self.avroOutputSchema = '/etc/ar-sync/downtimes.avsc'

    def loadConfiguration(self, configFields):
        if 'avroOutputDir' in configFields:
             self.avroOutputDir = configFields['avroOutputDir']
        if 'avroOutputFileTemplate' in configFields:
             self.avroOutputFileTemplate = configFields['avroOutputFileTemplate']
        if 'avroOutputSchema' in configFields:
             self.avroOutputSchema = configFields['avroOutputSchema']

    def writeDowntimes(self, downtimes, date):
        filename = createOutputFilename(self.avroOutputDir, self.avroOutputFileTemplate, date)

        schema = avro.schema.parse(open(self.avroOutputSchema).read())
        avroFile = open(filename, 'w+')
        writer = DataFileWriter(avroFile, DatumWriter(), schema)

        for dt in downtimes:
            writer.append(dt)
            if dt['service'] in LegMapServType.keys():
                dt['service'] = LegMapServType[dt['service']]
                writer.append(dt)

        writer.close()
        avroFile.close()

##############################
# main
##############################

argsOk = False
configFile = defaultConfig
for i in range(0,len(sys.argv)-1):
    if sys.argv[i] == '-d':
        if len(sys.argv[i+1].split('-')) == 3:
            date = sys.argv[i+1]
            argsOk = True
    if sys.argv[1] != '-d' and os.path.isfile(sys.argv[1]):
        configFile = sys.argv[1]
        argsOk = True

if not argsOk:
    print "\n\nUsage:\n\tpython downtime.py [config file] -d <date>"
    sys.exit()

# calculate start and end times
start = datetime.datetime.strptime(date, defaultArgDateFormat)
end = datetime.datetime.strptime(date, defaultArgDateFormat)
start = start.replace(hour=0, minute=0, second=0)
end = end.replace(hour=23, minute=59, second=59)

# load configuration
config = loadConfiguration(configFile)

# read downtimes
downtimes = list()
for reader in readers:
    if reader == 'gocdb':
        readerInstance = GOCDBReader()
        readerInstance.loadConfiguration(config)
        dts = readerInstance.getDowntimes(start, end)
        downtimes.extend(dts)

# write downtimes
for writer in writers:
    if writer == 'file':
        writerInstance = FileWritter()
        writerInstance.loadConfiguration(config)
        writerInstance.writeDowntimes(downtimes, date)
    elif writer == 'avro':
        writerInstance = AvroWritter()
        writerInstance.loadConfiguration(config)
        writerInstance.writeDowntimes(downtimes, date)
